# ⚙️ 좋은 알고리즘과 시간 복잡도

## 1. 좋은 알고리즘의 기준은 무엇인가?

- **좋은 알고리즘**은 사용자마다 기준이 다름:
  - 💾 메모리를 적게 쓰는 것을 선호하는 사용자
  - ⚡ 속도가 빠른 것을 선호하는 사용자

- 일반적으로는 **속도(실행 시간)**를 기준으로 알고리즘의 성능을 판단하며, 이를 **시간 복잡도(Time Complexity)**라고 함

---

## 2. 시간 복잡도(Time Complexity)란?

- 알고리즘의 **성능을 수치적으로 평가**하는 척도
- 실제 시간을 측정하는 것이 아니라, **입력 크기(n)**가 증가할 때 연산 횟수가 얼마나 늘어나는지를 기반으로 판단
- 주로 성능에 영향을 주는 부분은 **반복문**

---

## 3. 성능 평가 기준: 세 가지 경우

| 경우 | 설명 | 표기법 |
|------|------|--------|
| 최선의 경우 | 가장 빠른 상황 | **Ω(n)** (Big-Omega) |
| 평균적인 경우 | 일반적인 상황 | **Θ(n)** (Big-Theta) |
| 최악의 경우 | 가장 느린 상황 | **O(n)** (Big-O) |

> 일반적으로는 **최악의 경우 (Big-O)** 기준을 가장 많이 사용

---

## 4. 시간 복잡도의 예시

### 📌 O(1) — 상수 시간
- 입력 크기에 관계없이 일정한 시간
- 예: 배열의 특정 인덱스에 접근

### 📌 O(log n) — 로그 시간
- 이진 탐색과 같이 입력이 증가해도 연산 횟수는 천천히 증가

### 📌 O(n) — 선형 시간
- 입력이 증가할수록 연산 횟수도 비례하여 증가
- 예: 배열 전체를 순회하는 경우

### 📌 O(n log n)
- 병합 정렬 등에서 나타나는 복잡도

### 📌 O(n²)
- 중첩 반복문이 있을 때 발생
- 예: 버블 정렬

### 📌 O(2ⁿ)
- 입력이 조금만 증가해도 연산이 기하급수적으로 증가
- 예: 일부 재귀적인 조합 문제

---

## 5. 시간 복잡도 시각 자료

다음 그래프는 다양한 시간 복잡도에 따른 **입력 크기(n)**와 **연산량**의 관계를 시각적으로 보여줍니다:

![image](https://github.com/user-attachments/assets/725d8004-39ba-44ac-aa25-b31145c5cf14)


- 가장 효율적인 알고리즘: `O(1)` → 상수 시간 (녹색 선)
- 가장 비효율적인 알고리즘: `O(2ⁿ)` → 지수 시간 (파란색 선)
- 대부분의 정렬 알고리즘은 `O(n log n)` 또는 `O(n²)`에 위치

> n이 커질수록 알고리즘 간 **성능 차이가 극명하게 드러남**

---

## 6. 복잡도 표기 시 주의할 점

- **항 중에서 가장 영향력이 큰 항만 남기고 나머지는 생략**
- **상수 계수 제거**

### 예시:
- `2n² + 100` → **O(n²)**
- `3n³ + 100n` → **O(n³)**
- `5n²` → **O(n²)**

---

## 📚 정리

- 알고리즘 선택은 상황과 목적에 따라 다르며, 일반적으로는 **속도(시간 복잡도)**가 중요
- 반복문이 많은 알고리즘은 시간 복잡도가 높아질 수 있음
- Big-O 표기법을 통해 성능을 예측하고 비교할 수 있음
- 그래프를 통해 시간 복잡도별 성장률을 시각적으로 이해하는 것이 중요

---
